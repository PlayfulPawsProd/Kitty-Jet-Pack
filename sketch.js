// ~~~ store.js ~~~ //
// Magic spells for the Plushie Store! Nya~! (Kitty Colors Enabled!)

// --- Store Data ---
const storeItems = [
    { id: 'kitty_bow_pink', name: 'Pink Bow', cost: 1, description: 'A cute bow for kitty!', type: 'kitty_accessory', implemented: true },
    { id: 'jetpack_rainbow', name: 'Rainbow Trail FX', cost: 250, description: 'Leave a sparkly rainbow trail!', type: 'jetpack_fx', implemented: true },
    { id: 'kitty_color_black', name: 'Shadow Kitty', cost: 250, description: 'A sleek, mysterious look!', type: 'kitty_color', implemented: true }, // NOW IMPLEMENTED! Cost updated.
    { id: 'kitty_color_orange', name: 'Ginger Kitty', cost: 250, description: 'A classic marmalade friend!', type: 'kitty_color', implemented: true }, // NOW IMPLEMENTED! Cost updated.

    // WIP Items
    { id: 'plushie_magnet', name: 'Plushie Magnet', cost: 500, description: 'Attract nearby plushies!', type: 'power_up', implemented: false }
];

let purchasedItems = {}; // { 'itemId': true/false }
let equippedItems = { kitty_accessory: null, kitty_color: null, jetpack_fx: null }; // Added kitty_color type

let storeButtonHeight = 60; let storeButtonSpacing = 75;
let buyButtonWidth; let buyButtonHeight = 40;
let storeItemYStart; let storeBackButton;

// --- Calculate dynamic store layout elements ---
function setupStoreLayout(canvasW, canvasH) { /* ... same ... */ buyButtonWidth = canvasW * 0.25; storeItemYStart = canvasH * 0.20; storeBackButton = { x: 15, y: canvasH - 55, w: 100, h: 40 }; console.log("Store layout calculated!"); }

// --- Store Display Function ---
function displayStore(currentTotalPlushies) { /* ... same ... */ if (!width || !height) return; background(50, 50, 70, 220); fill(textColor); stroke(textStrokeColor); strokeWeight(3); textSize(min(width, height) * 0.08); text("Plushie Store!", width / 2, height * 0.1); textSize(min(width, height) * 0.05); strokeWeight(2); text(`Total Plushies: ${currentTotalPlushies}`, width / 2, height * 0.18); noStroke(); let itemY = storeItemYStart; storeItems.forEach((item, index) => { if (typeof purchasedItems[item.id] === 'undefined') { purchasedItems[item.id] = false; } fill(100, 100, 120, 200); rectMode(CORNER); rect(width * 0.05, itemY, width * 0.9, storeButtonHeight, 5); fill(textColor); textAlign(LEFT, TOP); textSize(min(width, height) * 0.035); stroke(textStrokeColor); strokeWeight(1); text(`${item.name}`, width * 0.08, itemY + 8); textSize(min(width, height) * 0.025); noStroke(); text(item.description, width * 0.08, itemY + 32); let buttonX = width * 0.95 - buyButtonWidth - (width * 0.03); let buttonTopY = itemY + (storeButtonHeight - buyButtonHeight) / 2; rectMode(CORNER); noStroke(); textSize(min(width, height) * 0.03); textAlign(CENTER, CENTER); let buttonText = ""; let buttonColor = color(150); let buttonTextColor = color(80); let isClickable = item.implemented; if (!item.implemented) { buttonText = "Soon!"; isClickable = false; } else if (purchasedItems[item.id]) { buttonColor = color(100, 150, 200); buttonTextColor = color(255); if (equippedItems[item.type] === item.id) { buttonText = "Unequip"; buttonColor = color(200, 100, 100); } else { buttonText = "Equip"; } } else { if (currentTotalPlushies >= item.cost) { buttonColor = color(100, 200, 100); buttonTextColor = color(0); } else { buttonColor = color(150); buttonTextColor = color(80); isClickable = false; } buttonText = `Buy (${item.cost})`; } if (!isClickable) { buttonColor = color(120); buttonTextColor = color(70); } fill(buttonColor); rect(buttonX, buttonTopY, buyButtonWidth, buyButtonHeight, 3); fill(buttonTextColor); stroke(textStrokeColor); strokeWeight(1); text(buttonText, buttonX + buyButtonWidth / 2, buttonTopY + buyButtonHeight / 2); itemY += storeButtonSpacing; }); if (storeBackButton) { fill(backButtonColor); rectMode(CORNER); noStroke(); rect(storeBackButton.x, storeBackButton.y, storeBackButton.w, storeBackButton.h, 5); fill(textColor); textSize(min(width, height) * 0.04); textAlign(CENTER, CENTER); stroke(textStrokeColor); strokeWeight(1.5); text("Back", storeBackButton.x + storeBackButton.w / 2, storeBackButton.y + storeBackButton.h / 2); } textAlign(CENTER, CENTER); noStroke(); }

// --- Store Input Handler ---
function handleStoreInput(px, py, currentTotalPlushies) { /* ... same logic ... */ if (!audioStarted) return false; if (storeBackButton && px >= storeBackButton.x && px <= storeBackButton.x + storeBackButton.w && py >= storeBackButton.y && py <= storeBackButton.y + storeBackButton.h) { gameState = 'start'; console.log("Exiting Store"); return true; } let itemY = storeItemYStart; let itemHandled = false; for (let item of storeItems) { let buttonX = width * 0.95 - buyButtonWidth - (width * 0.03); let buttonTopY = itemY + (storeButtonHeight - buyButtonHeight) / 2; if (px >= buttonX && px <= buttonX + buyButtonWidth && py >= buttonTopY && py <= buttonTopY + buyButtonHeight) { if (!item.implemented) { console.log("Clicked button for WIP item:", item.name); shakeTime = 8; itemHandled = true; break; } console.log("Clicked button for:", item.name); if (purchasedItems[item.id]) { if (equippedItems[item.type] === item.id) { equippedItems[item.type] = null; localStorage.removeItem(`equipped_${item.type}`); console.log(`Unequipped ${item.name}`); } else { equippedItems[item.type] = item.id; localStorage.setItem(`equipped_${item.type}`, item.id); console.log(`Equipped ${item.name}`); } itemHandled = true; break; } else { if (currentTotalPlushies >= item.cost) { console.log("Attempting to buy", item.name); purchasedItems[item.id] = true; try { localStorage.setItem(item.id, 'true'); } catch (e) { console.warn("Failed to save purchase:", e);} console.log("Purchased!", item.name); return item.cost; } else { console.log("Not enough plushies to buy", item.name); shakeTime = 10; itemHandled = true; break; } } } itemY += storeButtonSpacing; } return itemHandled; }

// --- Load Purchases and Equipped Items ---
function loadItems() { /* ... same ... */ console.log("Loading items..."); purchasedItems = {}; equippedItems = { kitty_accessory: null, kitty_color: null, jetpack_fx: null }; storeItems.forEach(item => { try { purchasedItems[item.id] = localStorage.getItem(item.id) === 'true'; } catch (e) { console.warn(`Could not load purchase status for ${item.id}:`, e); purchasedItems[item.id] = false; } }); for (let type in equippedItems) { try { let equippedId = localStorage.getItem(`equipped_${type}`); if (equippedId && purchasedItems[equippedId]) { equippedItems[type] = equippedId; console.log(`- Equipped ${type}: ${equippedId}`); } else { equippedItems[type] = null; localStorage.removeItem(`equipped_${type}`); } } catch (e) { console.warn(`Could not load equipped status for ${type}:`, e); equippedItems[type] = null; } } console.log("Item loading complete."); }

// --- Helper to check purchase status ---
function isItemPurchased(itemId) { return purchasedItems[itemId] === true; }

// --- Helper to check equipped status ---
function getEquippedItem(itemType) { return equippedItems[itemType]; } // Returns the ID or null
// PART 2 of 2 - Color Mode Revert Fix! Nya!

// Start Screen
function displayStartScreen() { /* ... same w/ update button draw ... */ fill(textColor); stroke(textStrokeColor); strokeWeight(2.5); let titleSize = min(width, height) * 0.095; let instructionSize = titleSize * 0.5; let masterSize = instructionSize * 1.1; let tapSize = instructionSize * 0.85; let highScoreSize = tapSize * 0.90; let totalPlushieSize = highScoreSize * 0.9; let buttonTextSize = instructionSize * 0.75; let updateButtonTextSize = buttonTextSize * 0.8; let versionTextSize = updateButtonTextSize * 0.7; let lineSpacingFactor = 1.2; textSize(titleSize); text("Kitty's Cuddle", width / 2, height * 0.18); text("Collection~♥", width / 2, height * 0.18 + titleSize * lineSpacingFactor); let instructionY = height * 0.18 + titleSize * lineSpacingFactor * 2.2; textSize(instructionSize); text("Ready for Liftoff?", width / 2, instructionY); instructionY += instructionSize * lineSpacingFactor; text("DRAG me left/right", width / 2, instructionY); instructionY += instructionSize * lineSpacingFactor * 0.9; text("to catch plushies,", width/2, instructionY); instructionY += instructionSize * lineSpacingFactor * 1.3; fill(kittyColor); textSize(masterSize); stroke(textStrokeColor); strokeWeight(2.5); text("Master~!", width/2, instructionY); instructionY += masterSize * lineSpacingFactor * 1.2; if (endlessModeButton) { endlessModeButton.y = instructionY; rectMode(CORNER); fill(endlessModeButtonColor); noStroke(); rect(endlessModeButton.x, endlessModeButton.y, endlessModeButton.w, endlessModeButton.h, 5); textSize(buttonTextSize); textAlign(CENTER, CENTER); stroke(textStrokeColor); strokeWeight(1.5); if (isEndlessMode) { fill(endlessModeTextColorOn); text("Endless Mode: ON", endlessModeButton.x + endlessModeButton.w / 2, endlessModeButton.y + endlessModeButton.h / 2); } else { fill(endlessModeTextColorOff); text("Endless Mode: OFF", endlessModeButton.x + endlessModeButton.w / 2, endlessModeButton.y + endlessModeButton.h / 2); } instructionY += endlessModeButton.h * 1.2; if (isEndlessMode) { noStroke(); fill(200); textSize(buttonTextSize * 0.8); text("(Score/Speed resets on Miss)", width / 2, instructionY); instructionY += buttonTextSize * 0.8 * lineSpacingFactor; } } if (storeButton) { storeButton.y = instructionY; rectMode(CORNER); fill(storeButtonColor); noStroke(); rect(storeButton.x, storeButton.y, storeButton.w, storeButton.h, 5); textSize(buttonTextSize * 0.9); textAlign(CENTER, CENTER); stroke(textStrokeColor); strokeWeight(1.5); fill(storeButtonTextColor); text("Store", storeButton.x + storeButton.w / 2, storeButton.y + storeButton.h / 2); instructionY += storeButton.h * 1.5; } fill(textColor); textSize(tapSize); strokeWeight(2); if (frameCount % 60 < 40) { text("Tap Here or Above to FLY!", width / 2, instructionY); } instructionY += tapSize * lineSpacingFactor * 1.5; textSize(highScoreSize); fill(200); stroke(textStrokeColor); strokeWeight(2); text(`Normal High Score: ${highScore}`, width/2, instructionY); instructionY += highScoreSize * lineSpacingFactor; text(`Endless Streak High Score: ${endlessHighScore}`, width/2, instructionY); instructionY += highScoreSize * lineSpacingFactor; textSize(totalPlushieSize); text(`Total Plushies Collected: ${totalPlushiesCollected}`, width/2, instructionY); if (updateButton) { let currentUpdateButtonColor = updateButtonColor; let currentUpdateButtonTextColor = updateButtonTextColor; if (updateButtonState === 'checking') { currentUpdateButtonColor = color(150, 150, 80); currentUpdateButtonTextColor = color(50); } else if (updateButtonState === 'available') { currentUpdateButtonColor = updateAvailableColor; currentUpdateButtonTextColor = color(0); } else if (updateButtonState === 'uptodate' || updateButtonState === 'error') { currentUpdateButtonColor = color(100); currentUpdateButtonTextColor = color(180); } rectMode(CORNER); fill(currentUpdateButtonColor); noStroke(); rect(updateButton.x, updateButton.y, updateButton.w, updateButton.h, 5); fill(currentUpdateButtonTextColor); stroke(textStrokeColor); strokeWeight(1); textSize(updateButtonTextSize); textAlign(CENTER, CENTER); text(updateButtonText, updateButton.x + updateButton.w / 2, updateButton.y + updateButton.h / 2); } textSize(versionTextSize); fill(150); noStroke(); textAlign(LEFT, BOTTOM); text(gameVersion, 5, height - 5); noStroke(); textAlign(CENTER, CENTER); }
// Game Over Cutscene Display (No changes)
function displayGameOverCutscene() { /* ... same ... */ let lineY = height * 0.2; let lineSpacing = min(width, height) * 0.05; let baseTextSize = lineSpacing * 0.7; let textBlockHeight = 0; let textBlockWidth = width * 0.85; let boxCenterY = height * 0.45; if (cutsceneStep <= 1) textBlockHeight = lineSpacing * 2.5; else if (cutsceneStep === 2) textBlockHeight = lineSpacing * 3.5; else if (cutsceneStep === 3) textBlockHeight = lineSpacing * 2.5; else if (cutsceneStep === 4) textBlockHeight = lineSpacing * 4; else if (cutsceneStep === 5) textBlockHeight = lineSpacing * 2.5; else textBlockHeight = lineSpacing * 3; fill(textBgColor); rectMode(CENTER); rect(width / 2, boxCenterY, textBlockWidth, textBlockHeight, 15); fill(textColor); textSize(baseTextSize); let currentLineY = boxCenterY - textBlockHeight / 2 + lineSpacing; if (cutsceneStep === 0) { text("*Phew...*", width / 2, currentLineY); text("That was a LOT of plushies...", width / 2, currentLineY + lineSpacing); } else if (cutsceneStep === 1) { text("I think... I think I got them all...?", width / 2, currentLineY); text("(Finally... peace and quiet...)", width / 2, currentLineY + lineSpacing); } else if (cutsceneStep === 2) { text("Wait... what's that noise?", width / 2, currentLineY); text("*Clatter! Crash!*", width/2, currentLineY + lineSpacing); text("Oh no... not AGAIN!", width / 2, currentLineY + lineSpacing * 2); } else if (cutsceneStep === 3) { text("KANA! DON'T TOUCH THAT--!", width / 2, currentLineY + lineSpacing); if(shakeTime <= 0) shakeTime = 15; } else if (cutsceneStep === 4) { textSize(baseTextSize * 1.8); fill(boomColor); text("*** KABOOOOOOM!!! ***", width / 2, currentLineY + lineSpacing * 1.5); textSize(baseTextSize); fill(textColor); for(let i=0; i<5; i++) { fill(random(plushieColors)); rect(random(width), random(height*0.6, height), 15, 15); } } else if (cutsceneStep === 5) { text("NYAAAAAAAAA!", width / 2, currentLineY); text("They're everywhere AGAIN!", width / 2, currentLineY + lineSpacing); } else if (cutsceneStep === 6) { text("They're everywhere AGAIN!", width / 2, currentLineY); textSize(baseTextSize * 0.8); text("(Tap to see your score... *sigh*)", width / 2, currentLineY + lineSpacing); } if (cutsceneStep < 6) { textSize(baseTextSize * 0.7); fill(200); text("[Tap to continue]", width / 2, height - lineSpacing * 0.7); } rectMode(CORNER); }
// Game Over Screen (No changes)
function displayGameOverScreen() { /* ... same ... */ fill(textColor); let gameOverSize = min(width, height) * 0.09; let messageSize = gameOverSize * 0.55; let scoreSize = messageSize * 0.9; let retrySize = scoreSize * 0.8; let lineSpacingFactor = 1.3; let endlessModeMsgSize = retrySize * 0.9; textSize(gameOverSize); let currentY = height * 0.15; let finalDifficultyStageNum = difficultyStage + 1; if (!isEndlessMode) { if (difficultyStage >= 5) { text("KITTY OVERLOAD!", width / 2, currentY); currentY += gameOverSize * lineSpacingFactor; textSize(messageSize); text(`You got ${score} adorable plushies!`, width / 2, currentY); currentY += messageSize * lineSpacingFactor; text(`Survived until Difficulty ${finalDifficultyStageNum}!`, width/2, currentY); currentY += messageSize * lineSpacingFactor; text("Truly Purrfect, Master!", width / 2, currentY); currentY += messageSize * lineSpacingFactor; fill(kittyColor); text("Our infinite hoard thanks you~♥", width / 2, currentY); } else { text("Grounded!", width / 2, currentY); currentY += gameOverSize * lineSpacingFactor; textSize(messageSize); text(`${score} plushies? Pathetic!`, width / 2, currentY); currentY += messageSize * lineSpacingFactor; text(`Stuck near the city (Stage 1)...`, width/2, currentY); currentY += messageSize * lineSpacingFactor; text("Need more practice!", width / 2, currentY); currentY += messageSize * lineSpacingFactor; fill(150, 0, 0); text("*Pouty Jetpack Sputters*", width/2, currentY); } } else { text("Endless Flight Over!", width / 2, currentY); currentY += gameOverSize * lineSpacingFactor; textSize(messageSize); text(`Final Streak: ${highestStreakInSession}`, width / 2, currentY); currentY += messageSize * lineSpacingFactor * 1.5; text("Ready for another run?", width / 2, currentY); } currentY += messageSize * lineSpacingFactor * 1.2; textSize(scoreSize * 0.9); fill(200); text(`(Normal High Score: ${highScore})`, width/2, currentY); currentY += scoreSize * 1.3; text(`(Endless Streak High Score: ${endlessHighScore})`, width/2, currentY); if (isEndlessMode) { textSize(endlessModeMsgSize); fill(endlessModeTextColorOn); currentY += scoreSize * 1.3; text("(Endless Mode - Score Not Saved for Normal High Score)", width / 2, currentY); } fill(textColor); textSize(retrySize); if (frameCount % 60 < 40) { text("Tap Anywhere to Fly Again!", width / 2, height * 0.88); } }
// HUD Display (No changes needed)
function displayHUD() { /* ... same ... */ let hudTextSize = min(width, height) * 0.04; let heartSize = hudTextSize * 1.3; let backTextSize = hudTextSize * 0.9; let bestRunTextSize = hudTextSize * 1.1; let currentHudTextColor = hudTextColorLight; if (visualStage === maxVisualStageIndex && isEndlessMode) { currentHudTextColor = hudTextColorDark; } fill(currentHudTextColor); stroke(textStrokeColor); strokeWeight(1.5); textSize(hudTextSize); textAlign(LEFT, TOP); let lineY = 15; let lineSpacing = hudTextSize * 1.3; text(`Plushies: ${score}`, 15, lineY); lineY += lineSpacing; text(`Difficulty: ${difficultyStage + 1}`, 15, lineY); lineY += lineSpacing; if (isEndlessMode) { fill(endlessModeTextColorOff); textSize(hudTextSize); text(`Best Run: `, 15, lineY); fill(endlessModeTextColorOn); textSize(bestRunTextSize); text(`${highestStreakInSession}`, 15 + textWidth("Best Run: "), lineY); lineY += lineSpacing; fill(endlessModeTextColorOn); textSize(bestRunTextSize); text(`Streak: ${currentStreak}`, 15, lineY); } else { textAlign(RIGHT, TOP); let hearts = ''; for (let i = 0; i < lives; i++) { hearts += '♥ '; } fill(heartColor); textSize(heartSize); noStroke(); text(hearts, width - 15, 10); } if (gameState === 'playing' && isEndlessMode && backButton) { rectMode(CORNER); fill(backButtonColor); noStroke(); rect(backButton.x, backButton.y, backButton.w, backButton.h, 3); fill(textColor); stroke(textStrokeColor); strokeWeight(1.5); textSize(backTextSize); textAlign(CENTER, CENTER); text("Back", backButton.x + backButton.w / 2, backButton.y + backButton.h / 2); } textAlign(CENTER, CENTER); noStroke(); }

// --- Helper Functions ---
function spawnPlushie() { /* ... same ... */ if(!kitty) return; let plushieSize = kitty.size * 0.8; let spawnX = random(plushieSize, width - plushieSize); let plushie = { x: spawnX, y: -plushieSize, size: plushieSize, color: random(plushieColors), dx: random(-currentPlushieDrift, currentPlushieDrift) }; plushies.push(plushie); }
// drawKitty - UPDATED to check equipped color!
function drawKitty(inCutscene = false) {
    if(!kitty) return;
    let drawBow = false;
    let currentFillColor = defaultKittyColor; // Start with default pink

    // Check store functions exist before calling
    if (typeof getEquippedItem === 'function') {
        // Check for equipped color
        let equippedColorId = getEquippedItem('kitty_color');
        if (equippedColorId === 'kitty_color_black') {
            currentFillColor = shadowKittyColor;
        } else if (equippedColorId === 'kitty_color_orange') {
            currentFillColor = gingerKittyColor;
        }

        // Check for bow
        if (getEquippedItem('kitty_accessory') === 'kitty_bow_pink') {
            drawBow = true;
        }
    }

    // Draw Jetpack FIRST
    if (kitty.hasJetpack) { /* ... same jetpack drawing ... */ rectMode(CENTER); fill(jetpackColor); stroke(50); strokeWeight(max(1, kitty.size * 0.03)); rect(kitty.x, kitty.y + kitty.size * 0.1, kitty.size * 0.6, kitty.size * 0.7, kitty.size * 0.1); rect(kitty.x - kitty.size * 0.2, kitty.y + kitty.size * 0.4, kitty.size * 0.15, kitty.size * 0.2); rect(kitty.x + kitty.size * 0.2, kitty.y + kitty.size * 0.4, kitty.size * 0.15, kitty.size * 0.2); if (!inCutscene || cutsceneStep < 3 || cutsceneStep > 4) { let flameSize = kitty.size * map(abs(kitty.bobOffset), 0, kitty.size * 0.05, 0.3, 0.6) * random(0.8, 1.2); if (!(typeof getEquippedItem === 'function' && getEquippedItem('jetpack_fx') === 'jetpack_rainbow')){ fill(255, random(150, 200), 0, 200); noStroke(); triangle(kitty.x - kitty.size * 0.2, kitty.y + kitty.size * 0.5, kitty.x - kitty.size * 0.2 - flameSize * 0.3, kitty.y + kitty.size * 0.5 + flameSize, kitty.x - kitty.size * 0.2 + flameSize * 0.3, kitty.y + kitty.size * 0.5 + flameSize); triangle(kitty.x + kitty.size * 0.2, kitty.y + kitty.size * 0.5, kitty.x + kitty.size * 0.2 - flameSize * 0.3, kitty.y + kitty.size * 0.5 + flameSize, kitty.x + kitty.size * 0.2 + flameSize * 0.3, kitty.y + kitty.size * 0.5 + flameSize); } } }

    // Draw Kitty Body (using determined color)
    fill(currentFillColor); stroke(50); strokeWeight(max(1, kitty.size * 0.05));
    rectMode(CENTER); rect(kitty.x, kitty.y, kitty.size, kitty.size);
    // Ears
    let earSize = kitty.size * 0.4; let earOffset = kitty.size * 0.1; triangle(kitty.x - kitty.size/2 + earOffset, kitty.y - kitty.size/2, kitty.x - kitty.size/2 + earOffset, kitty.y - kitty.size/2 - earSize, kitty.x - earOffset, kitty.y - kitty.size/2); triangle(kitty.x + kitty.size/2 - earOffset, kitty.y - kitty.size/2, kitty.x + kitty.size/2 - earOffset, kitty.y - kitty.size/2 - earSize, kitty.x + earOffset, kitty.y - kitty.size/2);
    // Tail
    strokeWeight(max(2, kitty.size * 0.1)); line(kitty.x + kitty.size / 2, kitty.y, kitty.x + kitty.size * 0.8, kitty.y - kitty.size*0.2);
    // Eyes
    let eyeSize = kitty.size * 0.1; fill(40); noStroke(); ellipse(kitty.x - kitty.size * 0.2, kitty.y - kitty.size * 0.1, eyeSize, eyeSize); ellipse(kitty.x + kitty.size * 0.2, kitty.y - kitty.size * 0.1, eyeSize, eyeSize);
    // Draw Bow if Equipped
    if (drawBow) { let bowSize = kitty.size * 0.3; fill(255, 100, 150); stroke(50); strokeWeight(1); let bowX = kitty.x; let bowY = kitty.y - kitty.size * 0.5; triangle(bowX - bowSize, bowY, bowX, bowY - bowSize * 0.4, bowX, bowY + bowSize * 0.4); triangle(bowX + bowSize, bowY, bowX, bowY - bowSize * 0.4, bowX, bowY + bowSize * 0.4); }
    rectMode(CORNER); noStroke();
}
// drawPlushie (No changes needed)
function drawPlushie(p) { /* ... same ... */ fill(p.color); stroke(50); strokeWeight(max(1, p.size * 0.04)); rectMode(CENTER); rect(p.x, p.y, p.size, p.size); let eyeSize = p.size * 0.1; fill(40); ellipse(p.x - p.size * 0.2, p.y - p.size * 0.1, eyeSize, eyeSize); ellipse(p.x + p.size * 0.2, p.y - p.size * 0.1, eyeSize, eyeSize); rectMode(CORNER); noStroke(); }
// checkCollision (No changes needed)
function checkCollision(player, obj) { /* ... same ... */ if(!player || !obj) return false; let kittyLeft = player.x - player.size / 2, kittyRight = player.x + player.size / 2; let kittyTop = player.y - player.size / 2, kittyBottom = player.y + player.size / 2; let plushieLeft = obj.x - obj.size / 2, plushieRight = obj.x + obj.size / 2; let plushieTop = obj.y - obj.size / 2, plushieBottom = obj.y + obj.size / 2; let noOverlap = kittyLeft > plushieRight || kittyRight < plushieLeft || kittyTop > plushieBottom || kittyBottom < plushieTop; return !noOverlap; }
// isPointInKitty (No changes needed)
function isPointInKitty(px, py) { /* ... same ... */ if(!kitty) return false; let buffer = kitty.size * 0.5; let kittyLeft = kitty.x - kitty.size / 2 - buffer, kittyRight = kitty.x + kitty.size / 2 + buffer; let kittyTop = kitty.y - kitty.size / 2 - buffer, kittyBottom = kitty.y + kitty.size / 2 + buffer; return px >= kittyLeft && px <= kittyRight && py >= kittyTop && py <= kittyBottom; }

// --- Input Handling --- (No changes needed here)
function handlePressStart() { /* ... same ... */ if (!userHasInteracted) { userHasInteracted = true; userStartAudio().then(() => { console.log("Audio context ready! Nyaa!"); audioStarted = true; }, (e) => { console.error("userStartAudio failed:", e); audioStarted = false; }); } let pressX = mouseX; let pressY = mouseY; try { if (touches.length > 0 && touches[0]) { pressX = touches[0].x; pressY = touches[0].y; } } catch(e) { console.warn("Error accessing touch data:", e); return; } let endlessButtonDefined = (typeof endlessModeButton !== 'undefined' && endlessModeButton !== null); let storeButtonDefined = (typeof storeButton !== 'undefined' && storeButton !== null); let backButtonDefined = (typeof backButton !== 'undefined' && backButton !== null); let updateButtonDefined = (typeof updateButton !== 'undefined' && updateButton !== null); if (gameState === 'playing' && isEndlessMode && backButtonDefined) { if (pressX >= backButton.x && pressX <= backButton.x + backButton.w && pressY >= backButton.y && pressY <= backButton.y + backButton.h) { console.log("Back button pressed!"); if (highestStreakInSession > endlessHighScore) { endlessHighScore = highestStreakInSession; try { localStorage.setItem('kittyEndlessHighScore', endlessHighScore); console.log("New Endless High Score Saved:", endlessHighScore); } catch(e){ console.warn("Failed to save endless high score:", e); } } try { localStorage.setItem('kittyTotalPlushies', totalPlushiesCollected); } catch(e){ console.warn("Failed to save total plushies:", e); } gameState = 'start'; resetGame(); return; } } if (gameState === 'start') { if (updateButtonDefined && pressX >= updateButton.x && pressX <= updateButton.x + updateButton.w && pressY >= updateButton.y && pressY <= updateButton.y + updateButton.h) { if (updateButtonState === 'idle' || updateButtonState === 'uptodate' || updateButtonState === 'error') { checkVersion(); } else if (updateButtonState === 'available') { console.log("Reloading for update..."); window.location.reload(true); } return; } if (endlessButtonDefined && pressX >= endlessModeButton.x && pressX <= endlessModeButton.x + endlessModeButton.w && pressY >= endlessModeButton.y && pressY <= endlessModeButton.y + endlessModeButton.h) { isEndlessMode = !isEndlessMode; console.log("Endless Mode Toggled:", isEndlessMode); return; } if (storeButtonDefined && pressX >= storeButton.x && pressX <= storeButton.x + storeButton.w && pressY >= storeButton.y && pressY <= storeButton.y + storeButton.h) { console.log("Store button pressed! Entering store..."); gameState = 'store'; return; } } if (gameState === 'store') { if (typeof handleStoreInput === 'function') { let purchaseCost = handleStoreInput(pressX, pressY, totalPlushiesCollected); if (typeof purchaseCost === 'number' && purchaseCost > 0) { totalPlushiesCollected -= purchaseCost; try { localStorage.setItem('kittyTotalPlushies', totalPlushiesCollected); } catch(e){ console.warn("Failed to save total plushies after purchase:", e); } } } else { console.warn("handleStoreInput function not found! Switching back to start."); gameState = 'start'; } return; } if (gameState === 'intro') { if (introStep < 12) { if (introStep === 1) { shakeTime = 15; } else if (introStep === 5) { kitty.hasJetpack = true; } else { shakeTime = 0; } introStep++; } else { gameState = 'start'; } } else if (gameState === 'start') { kitty.hasJetpack = true; resetGame(); gameState = 'playing'; } else if (gameState === 'gameOverCutscene') { if (cutsceneStep < 6) { if (cutsceneStep === 2) { shakeTime = 15; } else if (cutsceneStep === 3) { shakeTime = 15;} else { shakeTime = 0; } cutsceneStep++; } else { gameState = 'gameOver'; } } else if (gameState === 'gameOver') { gameState = 'start'; } else if (gameState === 'playing') { if (pressX !== undefined && kitty && isPointInKitty(pressX, pressY)) { isDragging = true; } } }
// --- Version Check Function ---
function checkVersion() { /* ... same ... */ if (updateButtonState === 'checking') return; console.log("Checking for updates..."); updateButtonState = 'checking'; updateButtonText = "Checking..."; clearTimeout(updateCheckTimeout); const versionUrl = 'version.json'; fetch(versionUrl + '?t=' + Date.now()).then(response => { if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } return response.json(); }).then(data => { if (data && data.version) { console.log(`Current Version: ${gameVersion}, Latest Version: ${data.version}`); if (data.version !== gameVersion) { console.log("Update Available!"); updateButtonState = 'available'; updateButtonText = "Update Found!"; } else { console.log("Game is up to date! Nya~!"); updateButtonState = 'uptodate'; updateButtonText = "Up to Date! ♡"; updateCheckTimeout = setTimeout(() => { updateButtonState = 'idle'; updateButtonText = "Check Updates"; }, 3000); } } else { throw new Error("Invalid version data received."); } }).catch(error => { console.error("Error checking version:", error); updateButtonState = 'error'; updateButtonText = "Check Failed :("; updateCheckTimeout = setTimeout(() => { updateButtonState = 'idle'; updateButtonText = "Check Updates"; }, 5000); }); }
// Standard p5 mouse/touch listeners
function mousePressed() { handlePressStart(); if (mouseX > 0 && mouseX < width && mouseY > 0 && mouseY < height) { return false; } }
function touchStarted() { handlePressStart(); if (touches.length > 0 && touches[0] && touches[0].x > 0 && touches[0].x < width && touches[0].y > 0 && touches[0].y < height) { return false; } }
function mouseDragged() { if (isDragging && gameState === 'playing') { if(!kitty) return; kitty.x = mouseX; kitty.x = constrain(kitty.x, kitty.size / 2, width - kitty.size / 2); } if (isDragging) { return false; } }
function touchMoved() { if (isDragging && gameState === 'playing') { if(!kitty) return; if (touches.length > 0 && touches[0]) { kitty.x = touches[0].x; kitty.x = constrain(kitty.x, kitty.size / 2, width - kitty.size / 2); } } if (isDragging) { return false; } }
function mouseReleased() { if (isDragging) { isDragging = false; } }
function touchEnded() { if (isDragging) { isDragging = false; } }
// resetGame (No changes needed)
function resetGame() { /* ... same ... */ if (lastGameState === 'playing') { try { localStorage.setItem('kittyTotalPlushies', totalPlushiesCollected); console.log("Total plushies saved on reset:", totalPlushiesCollected); } catch(e){ console.warn("Failed to save total plushies:", e); } } score = 0; if (!isEndlessMode) lives = 3; plushies = []; difficultyStage = 0; visualStage = 0; previousVisualStage = 0; currentStreak = 0; highestStreakInSession = 0; if(kitty) kitty.x = width / 2; isDragging = false; frameCount = 0; shakeTime = 0; initializeBackgroundElements(); earthY = height * 1.5; lastDifficultyIncreaseScore = -1; currentEncouragingMessage = random(encouragingMessages); transitionStartTime = -Infinity; if(skyColors && skyColors.length > 0) { currentBgColor = skyColors[0]; targetBgColor = skyColors[0]; } cutsceneStep = 0; }

// END OF PART 2